#pragma once
#include <cmath>
#include <vector>

// generated by Gemini, edited

template <class RealType>
struct QuadratureRule
{
  //constructor

  std::vector<RealType> nodes;
  std::vector<RealType> weights;
};

template <class RealType>
QuadratureRule<RealType> computeGaussJacobi(int n, RealType alpha, RealType beta) {
  // catch invalid input
  if (n <= 0 || alpha <= -1.0 || beta <= -1.0)
  {
  }

  // initialize the pair of vectors
  QuadratureRule<RealType> rule;
  rule.nodes.resize(n);
  rule.weights.resize(n);

  // Precompute recurrence coefficients to save floating-point operations in the inner loop, basically construct the matrix
  struct RecurrenceCoeffs { double a1, a2, a3, a4; };
  std::vector<RecurrenceCoeffs> coeffs(n);
  for (int j = 1; j < n; ++j) {
      double Aj = 2.0 * j + alpha + beta;
      coeffs[j].a1 = 2.0 * (j + 1.0) * (j + alpha + beta + 1.0) * Aj;
      coeffs[j].a2 = (Aj + 1.0) * (alpha * alpha - beta * beta);
      coeffs[j].a3 = Aj * (Aj + 1.0) * (Aj + 2.0);
      coeffs[j].a4 = 2.0 * (j + alpha) * (j + beta) * (Aj + 2.0);
  }

  // Constant factor for the weights calculation, computed via log-gamma to prevent overflow
  // i dont understand this block of code
  double log_C = (alpha + beta + 1.0) * std::log(2.0) +
                 std::lgamma(n + alpha + 1.0) + std::lgamma(n + beta + 1.0) -
                 std::lgamma(n + 1.0) - std::lgamma(n + alpha + beta + 1.0);
  double C = std::exp(log_C);

  // Portable way to define PI, sure? ig
  const double pi = std::acos(-1.0);

  // parallelize?
  for (int k = 1; k <= n; k++)
  {
    // initial guess via Szego's asymptotic formula
    double theta = pi * (k - 0.25 + alpha / 2.0) / (n + (alpha + beta + 1.0) / 2.0);
    double root = std::cos(theta);

    double p1 = 0.0, dp1 = 0.0;

    // Newton-Raphson iteration
    const int MAX_ITER = 100;
    const double TOL = 1e-14;
    
    for (int iter = 0; iter < MAX_ITER; iter++)
    {
      double p0 = 1.0;
      p1 = 0.5 * (alpha - beta + (alpha + beta + 2.0) * root);
      double dp0 = 0.0;
      dp1 = 0.5 * (alpha + beta + 2.0);

      // Evaluate P_n(x) and P'_n(x) using the three-term recurrence
      for (int j = 1; j < n; ++j)
      {
        const auto& c = coeffs[j];
        double p_next = ((c.a2 + c.a3 * root) * p1 - c.a4 * p0) / c.a1;
        double dp_next = ((c.a2 + c.a3 * root) * dp1 + c.a3 * p1 - c.a4 * dp0) / c.a1;
        
        p0 = p1; 
        p1 = p_next;
        dp0 = dp1; 
        dp1 = dp_next;
      }

      double step = p1 / dp1;
      root -= step;

      // Convergence check
      if (std::abs(step) < TOL) {
        break;
      }
    }

    // Store the node (roots are generated in decreasing order from +1 to -1)
    rule.nodes[k - 1] = root;
    // Calculate the corresponding weight
    rule.weights[k - 1] = C / ((1.0 - root * root) * dp1 * dp1);
  }

  return rule;
}
